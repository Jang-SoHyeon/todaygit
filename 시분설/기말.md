### 아키텍쳐 설계
: 분석 단계에서 찾아낸 클래스와 메소드 교통 정리  
    - 패키지 - 클래스의 묶음으로 정리  ㅋㅋ
    - 서브 시스템의 구성과 인터페이스 정하기  
<img src="../image/아키텍쳐 설계.png" width = 50%>  

### 바람직한 설계?(이부분 제대로 못들어 불명확함)
: 복잡성 최소화  
    - 단순화, 복잡함을 최소화  
: 편리한 유지 관리  
    - 모듈화  
    - 표준화  
    - 컴포넌트화  
### 설계수준
: 표현하려는 내용이 다 표현되었는지 확인  
: 다른 다이어그램에도 동일하게 표현되었는지 확인  
<img src="../image/설계 수준.png" width = 50%>  

### 아키텍처 패턴
아키텍처 주요 스타일  
- 클라이언트 서버형  
- 계층형 
- 이벤트 기반 아키텍처
- MVC
- 파이프 필터
- 데이터 중심 아키텍처
- Peer-to-Peer 스타일 

### 설계목표
성능 목표  
신용도  
사용자 목표  
비용 목표  
유지보수 목표 


### 성능목표 신용도 사용자 목표 비용목포 유지보수 목표 각 정의(정의 뭔지 그대로 외우지말라? <<< 이런거 중간때 표내용 던져주고 주관식으로 나옴)
<img src= "../image/성능 목표.png" width = 100%>

<img src= "../image/비용 목표.png" width = 100%>

### 서브시스템?
응용 도메인의 복잡도를 줄이기 위하여 작은 부품인 클래스를 패키지로 그루핑하여 구조화  
설계 단계에서 솔루션을 포함하여 시스템을 분할 한 거   

### 아키텍처 유형
: 구조의 유형, 스타일  
: 시스템 분할, 전체적인 제어 흐름, 경계조건의 처리, 서브시스템 사이의 커뮤니케이션 프로토콜 유형  
: 애플리케이션, 플랫폼, 도메인에 따라 다른 유형이 적합  
: 일단 시스템이 개발된 뒤에는 잘못된 구조를 바로잡기가 쉽지 않음   
### 클라이언트 서버
: 서버는 클라이언트에게 서비스를 제공  
: 서비스의 요구  
    - 원격 호출 메커니즘  
    - CORBA나 Java RMI의 공통 객체 브로커  
: 클라이언트  
     - 사용자로부터 입력을 받아 범위를 체크  
     - 데이터베이스 트랜잭션을 구동하여 필요한 모든 데이터를 수집  
: 서버  
     - 트랜잭션을 수행  
     - 데이터의 일관성을 보장  
### P2P방식
: 클라이언트 서버 유형의 일반화  
     - 각 서브시스템이 클라이언트 또는 서버로 동작  
### 3계층(MVC), 프론트 백 데이터  
MVC  
- 모델 서브시스템 : 도메인의 지식을 저장보관  
- 뷰 서브시스템 : 사용자에게 보여줌  
- 제어 서브시스템 : 사용자와의 상호 작용을 관리  
분리하는 이유  
: 사용자 인터페이스, 즉 뷰와 제어가 도메인 지식을 나타내는 모델보다는 더 자주 변경 될 수 있기 때문  

3계층  
- 인터페이스 층  
: 윈도우, 룰 체킹, 웹 페이지 등 사용자와 관련된 경계 객체를 포함한다.  
- 응용 로직 층 
: 애플리케이션에서 요구되는 처리, 룰 체킹, 통지 등을 구현하는 제어 및 엔티티 객체를 포함한다.  
- 저장 층 
: 데이터베이스에 지속하여 저장하는 객체의 스토리지, 검색, 질의를 구현한다.  

### 설계 패턴의 기본원리
설계 패턴  
객체 설계  
    - 애플리케이션 클래스와 구현을 이어주는 클래스가 필요  
    - 좋은 설계 조각들로 구성  
위임과 상속  
    - 어떤 클래스가 다른 클래스에 메시지를 보냄으로써 오퍼레이션을 구현하는 것  
설계 패텬의 요소  
1. 이름 - 다른 패턴과 구별할 수 있는 고유한 이름  
2. 문제 - 패턴이 사용되는 상황을 설명한 문제 설명 
3. 해결책 - 협력 클래스와 인터페이스의 집합 
4. 결과 - 설정한 설계 목표에 따라 고려된 저물질과 대안들을 기술 
### 설계
요구 분석 : '무엇을 만들 것인가'를 다루는 직업  
설계 : '어떻게 실현할 것인가'를 구체적으로 결정하는 활동  
1) 기본 구조 설계 - 아키텍처 설계로 각 모듈의 역할과 인터페이스를 정의  
2) 상세 설계 - 모듈 내부의 알고리즘, 데이터를 명세화   

좋은 설계를 위해서는  
- 설계서는 요구분석명세서의 내용을 모두 포함해야 함  
- 유지보수가 용이하도록 추적이 가능해야 함  
- 변화에 쉽게 적응할 수 있어야 함  
- 시스템 변경으로 인한 영향이 최소화되도록 국지적이어야 함  
- 설계서는 읽기 쉽고 이해하기 쉽게 작성해야 함  

### 설계원리(내용 제대로 못들음)
: 시스템을 구현하기 위해 시스템을 여러 서브시스템으로 나누고 서브 시스템의 요소를 하드웨어와 소프트웨어에 할당하는 것을 시스템 설계라 한다.  
: 시스템 설계는 설계의 첫 단계로 시스템 전체의 구조를 결정하며, 구체적인 설계에 들어가기 전에 이루어진다.  
: 소프트웨어 설계는 소프트웨어에 할당된 서브시스템을 설계하는 과정이다.  
: 요구사항 분석은 응용 분야의 개념에 초점을 맞추지만, 소프트웨어 설계 단계에서는 컴퓨터의 개념으로 초점이 이동  
: 분석 단계에서 밝혀진 요구사항은 설계를 위한 골격을제공하며 설계는 그 위에 살을 붙여가는 과정  
: 요구사항을 해결하기 위해 최소한 한가지의 해결 방안은 가지고 있어야 하며, 가능하면 여러 해결 방법을 찾아내고 그들을 평가하는 것이 필요  
: 소프트웨어 설계자는 여러 해결 방법 중 수행 시간, 기억장치 및 다른 비용과 자원들을 최소화 할 수 있는 방법을 선택하게 된다.  
### 상위 설계 && 관리적 관점 2단계(상세설계 기본설계)
설계는 관리적인 관점에서 크게 두 단계로 나눌 수 있음  
첫 번째 단계 : 기본 설계 단계  
소프트웨어 시스템의 구조와 데이터를 규명하며 사용자 인터페이스를 정의함  
두 번째 단계 : 상세 설계  
각 모듈의 구체적인 알고리즘에 초점을 맞추게 됨  
기본 설계는 상위 설계라고 부르기도 함  
기본 설계에서 상세 설계로 진행하며 시스템의 추상화의 수준을 낮춤  
설계 과정이 진행될수록 명세서에 더 구체적인 내용이 추가되어 설계 과정의 최종 산출물은 시스템 구현을 위한 기초로 사용  

### 기술적 관점 4단계로 나눔 (데이터, 구조, 프로시저, 인터페이스)
설계는 기술적인 관점에서 크게 4가지 활동  
(데이터 설계, 구조 설계, 프로시져 설계, 사용자 인터페이스 설계)  
데이터 설계 : 요구사항 분석 단계의 정보 모델링에서 밝혀진 정보를 이용하여 자료 구조와 데이터베이스를 설계한다.  
구조 설계 : 기능 모델링과 동적 모델링에 나타난 결과를 이용하여 프로그램 구조상에 있는 각 구성 요소(모듈)들 사이의 관계를 기술한다.  
프로시져 설계 : 각 모듈의 내부가 구체적으로 밝혀지며 어떤 알고리즘을 사용할지 결정한다.  
사용자 인터페이스 설계 : 사용자가 시스템의 기능에 접근할 수 있도록 하는 사용자 인터페이스를 설계한다.  

### 분할 중요성
소프트웨어도 개발과 운용, 유지보수를 효과적으로 행하기 위해 구성 요소(모듈, 엔티티 등)들로 분할 된다.  
이들 요소들은 각기 서로 다른 기능을 수행하는 독립성을 가지고 있어야 한다.  
분할에서 추구하는 중요한 원칙  
" 서로 연관되어 있는 부분들은 같은 구성요소에 있어야 하며, 서로 연관성이 없는 부분들은 연관성이 없는 구성요소들에 할당되어야 한다."  

### 5가지 원리 정의 예시(단순 효율 분할계층 추상 모듈화)
효율성 : 처리 시간과 기억 공간, 사용하는 자원이 적정하고 효과적이도록 한다.  
단순성 : 유지보수성에 영향을 주는 가장 중요한 특성, 복잡한 여러 가지 요소들 교통 정리하여 단순화하거나 복잡함을 최소화 한다.  
분할, 계층화 : 다루기 쉬운 덩어리로 분리하여 계층화 한다.  
추상화 : 자세한 부분에 좌우되지 않게 컴포넌트를 정의한다.   
모듈화 : 각 모듈이 외부와의 결합이 낮고 내부 요소가 응집되도록 한다.  

### 단계적 정제  
: 하향식 설계 방법에 주로 사용되며, 기본 설계 단계에서 나타나는 프로그램의 구조에서 점차 모듈에 대한 세부 사항으로 내려가며 구체화된다.  

### 모듈화  
문제를 소프트웨어의 구성요소가 될 만한 수준으로 분할하는 과정  
소프트웨어를 작은 구성 요소, 즉 패키지 또는 클래스로 나누는 것  

### 설계의 품질? 좋은 설계
좋은 설계를 명확히 정의 내리기가 쉽지 않다.  
좋은 설계는 효율적으로 프로그램을 할 수 있게 하여 주는 설계라 할 수도 있고, 소프트웨어의 진화 문제를 잘 해결할 수 있도록 변화에 쉽게 적응할 수 있는 설계라 정의할 수 있다.  
좋은 설계가 이루어졌다고 인식되기 위해서는 설계 결과인 설계 문서는 읽기 쉽고 이해하기 쉽게 만들어져야 하며, 시스템에 변화가 주어졌을 때 그 영향은 국소화(local)되어야 한다.  
모듈은 서로 독립적이어야 하고, 각 구성 요소는 내부의 응집력이 높아야 한다. 또한 모듈들 사이의 연결을 나타내는 결합도는 최소화 되어야 한다.  

### 객체지향 설계 원리 5가지 
- 단일 책임의 원리(SRP)
: 클래스의 역할과 책임을 단일화 하여 클래스를 변경해야 할 이유를 하나로 제한  
- 개방 폐쇄의 원리(ocp)
: 변경에는 닫혀 있어야 하고, 확장에는 열려 있어야 함  
- 리스코프 교체의 원리(LSP)
: 상위 클래스의 객체는 언제나 자신의 하위 클래스의 객체로 교체할 수 있어야 한다.   
- 인터페이스 분리의 원리(ISP)
: 클라이언트는 자신이 사용하지 않는 메서드와 의존 관계를 맺으면 안된다.  
- 의존관계 역전의 원리(DIP)  
: 클라이언트는 구체 클래스가 아닌 추상 클래스(인터페이스)에 의존해야 한다.  

### 아키텍처 스타일  
일반적인 모양과 조화를 위한 스타일을 정하는 작업   
주요 스타일  
- 클라이언트 서버형
- 계층형
- 이벤트 기반 아키텍처
- MVC
- 파이프 필터
- 데이터 중심 아키텍처
- Peer-to-Peer 스타일 

### 패턴은 뭐에 쓰이나  
- 쉽게 재사용 가능
- 설계 작업이 쉬워짐 
- 설계 관련 지식이 정리됨
- 디자인을 논의하기 위한 의사소통이 쉬워짐 
- 객체지향 설계

### 행위, 구조, 생성 패턴의 정의 정도 알기  
행위 패턴  
: 메시지 교환과 관련된 것으로 객체 간의 행위나 알고리즘 등과 관련된 패턴  
구조 패턴  
: 클래스나 객체의 구성(합성)으로 더 큰 구조를 만들어야 할 때 유용한 디자인 패턴  
생성 패턴  
: 코드의 유연성을 높일 수 있고 유지관리를 쉽게 만듦  

### 클래스와 테이블의 매핑 
단순 데이터 구조를 가진 클래스는 테이블로 매핑  
객체 식별자는 기본 키  
다른 클래스의 인스턴스를 속성으로 가지고 있는 클래스는 그 클래스를 위하여 별도의 테이블을 생성  
컨테이너 클래스가 여러 객체를 포함하는 관계에 있을 때 2개의 필드를 가진 별도의 테이블을 생성  
M대 N의 관계는 별도의 테이블  
1대 1 연관은 외부 키 속성으로 구현  

### 코드 타입(상식적인 수준에서 나옴)
순차 코드 - 특정한 순서대로 숫자나 문자를 지정 (0 ,1,2)  
블록 순차 코드 - 분류를 위하여 블록화된 숫자 코드   
문자 코드 - 카테고리를 기반으로 개별 아이텀을 구별하기 위하여 문자를 사용  
유효숫자 코드 - 십진수의 자리로 개별 아이텀을 구별  
암호 코드 - 숫자로 인코딩하기 위하여 키워드 사용   
액션 코드 - 관련 아이텀에 어떤 액션이 취해질 것인지를 나타냄  

### 코드 개발 팁(상식선에서 나옴) 
코드는 간결하게  
확장을 허용하라  
코드를 안정하게 유지하라  
코드를 유일하게 만들어라  
정렬이 가능한 코드를 사용하라  
혼돈 될 코드를 피해라  
의미 있는 코드를 만들라  
단일 목적으로 코드를 사용하라  
코드의 일관성을 유지 하라  

### 사용자 인터페이스 설계(인터페이스 구현 분리?)
사용자 인터페이스 설계 : 사용자가 시스템의 기능에 접근할 수 있도록 하는 사용자 인터페이스를 설계한다.  
### 인터페이스 부분
인터페이스와 구현의 분리  
인터페이스  
공개된 메소드의 프로토타입만을 정의해 놓은 것  
공개된 메소드를 인터페이스로 따로 정의하고 이를 구현 상속  
컴포넌트의 공개 인터페이스를 컴포넌트가 어떻게 구현되는지 상세하게 나타낸 것과 분리  

### 설계 가이드라인(옳은말만 객관식??, 맞는지 틀린지 읽어보기)
1. 설계는 소프트웨어 구성 요소들(흔히 모듈이라고 부름) 사이에 효과적인 제어를 가능하게 하는 계층 구조를 가져야 한다.
2. 설계는 논리적으로 분할되어 모듈화되어야 한다. 일반적으로 기능에 의한 모듈화가 이루어지며 설계는 모듈들 사이의 계층 구조를 보여준다.  
3. 모듈들 사이, 또는 외부 환경과의 인터페이스가 최소화 되도록 설계되어야 한다. 이는 모듈 내부의 응집도는 높아야 하고, 모듈들 사이의 결합도와 인터페이스는 최소화될 수 있도록 설계되어야 함을 의미한다.  
4. 분석 과정에서 나타난 결과를 활용하여 설계가 이루어져야 한다. 설계는 요구사항 분석 과정의 연장선상에서 보여져야 하며, 요구사항을 시렿ㄴ하기 위해 분석의 결과에 살을 붙여나가는 과정이다.  
### 추상화 (상식적 << 중간때 단어 주고 뭔지 맞추는 주관식으로 나왔음)
추상화 : 시스템의 핵심 특성에 초점을 두어 하나의 큰 시스템을 분할하는 원리  
캡슐화 : 분할된 핵심 정보만을 노출  
추상화  
대상에 대하여 특정한 목적에 관련된 정보에 집중하고 나머지 정보는 무시하는 관점  

### 모듈화란? 응집도란? 의존도란?
모듈화는 시스템을 지능적으로 관리할 수 있도록 하여주며, 복잡도의 문제를 해결해준다.  
모듈화는 시스템의 유지 보수와 수정을 용이하게 하여준다.  
### 인스펙션에서 강조한거 개발자 참여자의 분리 (상식적4)
인스펙션 참여자 4번과 5번을 분리해야하는 이유(발표자랑 개발자 분리)
: 기본적으로 개발자는 이 시스템의 문제점을 회피하는 것을 알고있음
방어적일것임, 문제는 이 과정에서 그러면 안된다 때문에 발표자랑 분리해야 됨 
### 오버뷰
: 인스펙션 절차에서 선택적으로 수행하는 단계  
### 각 인스펙션 단어 의미정도?( 외우진 말라고? 주관식)
인스펙션 : 체계적으로 정의된 절차를 기반으로 결함을 발견하기 위해 훈련된 엔지니어에 의해 수행되는 산출물의 동료 검토를 의미  

계획 : 인스펙션 리더에 의해 진행되는 활동  
준비 : 인스펙션 절차의 핵심 && 배포된 검토 대상 산출물을 각 인스펙터가 개별적으로 검토하는 단계  
인스펙션 미팅 : 모든 인스펙션 역할자가 한 장소에 모여 인스펙터들이 점검한 검토 결과를 확인하는 활동
### 각 클래스 구성  
추상 클래스 : <<Abstract>> 프로토 타입 표기  

### 동적 모델링 구현  
순서(시퀀스) 다이어그램   : 메세지의 호출을 표현  
상태 다이어그램 : 상태를 표현하는 법, 상태의 변환을 메소드로 구현하는 법  
액티비티 다이어그램 : 제어흐름을 메소드에 구현하는 법  
### 액티비티 다이어그램을 코딩하는 일반적인 규칙 
액션 상태는 메소드 호출이나 일반 계산 문장으로 구현  
제어 노드는 if-then-else 문장으로 구현  
병렬 노드는 스레드로 구현  
반복 구조는 while 루프로 구현  
### 시스템 전환 방법 4가지 방법 장단점(다나온다) & 데이터 변환과 시스템 전환 정책  
데이터 변환  
: 현재 사용하는 시스템의 데이터는 새 시스템이 도입되면서 전환되어야 함  
: 존재하지 않는 데이터는 수작업으로 정보를 모아야 함  
일정  
: 변경이 많지 않은 것부터 변환  
시스템 전환 방법***    
: 새로운 시스템을 온라인으로 만들고 예전 시스템을 퇴출 시키는 과정 
변환 방법  
- 즉시 변환
장점
새 시스템의 도입 효과가 조직에 즉각적으로 발생
오래된 시스템을 고집하여 새 시스템을 약화시킬 기회를 주지 않음   
단점   
문제가 발생할 경우 돌이킬 수 없음  
만일의 사태에 대한 계획이 필요  
- 병행 운영
장  
새 시스템이 문제가 있다면 돌이킬 수 있음  
과거 시스템과 새 시스템의 비교 가능  
단  
중첩되는 기간에 고객이 두 시스템의 비용을 지불할 경우 이중 비용 지출  
두 시스템의 출력을 비교하는 비용  
사용자가 친숙한 시스템을 고집하여 새 시스템을 쓰지 않을 수도 있음  

- 파일럿 운영
장  
즉시 전환과 병행 운영의 장점을 모두 취함  
리스크 감소, 비용 적음  
단   
파일럿의 성과를 정확히 판단하지 못하면 전면적인 적용에 문제가 될 수 있음  
- 단계적 운영
장  
서브시스템 각각에 주의를 기울여야 함  
첫 단계를 잘 선택하면 투자 회수가 빠름  
각 단계를 테스트하여 완벽한 시스템이 될 수 있음  
단  
초기 단계에 문제가 발생하면 새 시스템에 대한 나쁜 소문이 날 수 있음  
최종 전환 단계까지 수익을 오래 기다릴 수 있음  
### 사용자교육 유지보수
사용자 교육  
교육 계획 : 누가 무슨 교육을 받을건지 파악  
: 세 가지 그룹(사용자, 관리자, it 스텝)을 위한 교육 주제  
유지 보수  
시스템 가동 후 수저하는 세 가지 작업 (운영, 지원, 보안)  
유지보수 비용이 시스템의 생명주기 결정  
### 단계별 유지보수 비용
<img src = "../image/단계별 유지보수 비용.png" width = 100%>  

### 유지보수 팀 구성
분석가, 시스템 관리자, 프로그래머  
### 유지 보수
: 시스템 가동 후 수정하는 세 가지 작업 (운영, 지원, 보안)  
: 유지보수 비용이 시스템의 생명주기 결정  

### 유지보수 요청 관리
수정할 필요가 있을 때 콘트롤 없이 바로 수정하는 것은 위험  
단계를 밟아 관리  
<img src="../image/유지보수 요청 관리.png" width = 50%>

### 시스템  성능관리
현재 시스템의 성능을 모니터하고 미래 성능 요구를 예측  

### 형상관리(강조했던걸로 기억)
소프트웨어 개발 주기에서 개발 단계에 시스템 요구의 변경을 관리하기 위한 프로세스  
시스템을 이루는 여러가지 파일과 구성요소를 잘 정리하고 빌드하는데 도움이 되는 도구 사용  
형성 관리 작업   
    - 시스템 버전을 추적  
    - 유지보수 작업 후 업데이트를 설치  
    - 시스템의 모든 버전이 제대로 작동하는지 확인  
### 보안 필요한거 -> 유지 보수에 뭐가 필요한지  (옳고 그른거 객관식 o )  
시스템 보안  
- 모든 컴퓨터 시스템의 필수적, 물리적, 네트워크 ,애플리케이션, 파일,사용자 보안  
물리적 보안  
컴퓨터 설치 공간의 물리적 환경  
- 원하지 않는 침입으로부터 특별히 보호되어야  
컴퓨터실 보안  
- 감금 장치, 백업 시스템, 접근 통제 - 지문 인식 시스템, 홍채 인식 시스템  
서버와 데스크톱 컴퓨터  
- 보안 잠금 장치, 키보드 해킹 방지 장치, 개봉 흔적이 남는 케이스, 파워-온 패스워드  
노트북 컴퓨터  
- 지문 인식 장치, 추적 소프트웨어  
네트워크 보안  
암호화  
- 데이터를 인코딩하여 인증없이 접근할 수 없게 하는 과정   
네트워크 트래픽 암호화  
- 공개키 암호화, 개인키는 철저히 보안 유지, 공개키로 암호화한 메시지는 사용자의 개인키로만 복호화  
개인 네트워크  
- 모든 네트워크의 트래픽을 보호하는 것은 비현실적  
- 컴퓨터를 연결하기 위하여 개인적인 네트워크를 사용  
가상 네트워크  
- 큰 그룹을 연결하기 위하여 가상 개인 네트워크 사용  
- 인증 받은 원거리 클라이언트가 특수 키 교환  
포트와 서비스  
- 포트 스캔, 서비스 공격을 거부  
방화벽  
- 로컬 네트워크나 인트라넷과 인터넷 사이에 설치한 방어선  
- 트래픽을 패스할 것인지 말 것인지를 결정하는 조건을 규칙으로 정의  
애플리케이션 보안  
- 서버의 애플리케이션과 애플리케이션에 의하여 야기도리 수 있는 보안 영향에 대하여 인지  
서비스  
- 특정한 애플리케이션이 필요 없다면 사용불능 상태로 두어 시스템의 성능과 신뢰도를 높임  
입력 검증   
- 데이터의 통일성과 품질을 안전하게 유지할 수 있는 중요한 기술  
패치와 업데이트  
- 서버나 애플리케이션의 보수하거나 취약점을 감소시키기 윟나 소프트웨어 모듈  
사용자 보안
마지막 수준
- 시스템 사용자 파악, 사용자 관련 보안 이슈 고려 
- 침입은 사용자 계정으로부터  
신원 관리  
- 정식 사용자와 시스템 컴포넌트를 파악하기 위하여 필요한 제어와 절차  
- 사용자 인증, 휴대 가능한 전사적 인증 및 제어 기술 
- 사용자 패스워드가 가장 중요  
패스워드 보호  
- 최소한의 길이와 대소문자 및 특수문자, 숫자를 혼용한 패스워드  
- 패스워드 유지 시간 제한  
### 파일보안
컴퓨터 환경 세팅, 사용자 개인 정보, 다른 민감한 데이터가 저장  

권한 지정  
파일 읽기 - 사용자가 파일 읽을 수 o
파일 쓰기 - 사용자가 파일 변경 o 
파일 실행 - 프로그램이면 사용자가 파일 실행 o 
디렉토리 읽기 - 사용자가 디렉토리에 있는 내용을 나열  o
디렉토리 쓰기 - 사용자가 디레고리에 파일을 추가 or 삭제 o 

사용자 그룹  
: 파일 권한을 그룹별로 배정  
: 맡은 책임으로 권한 결정  
### 테스트를 왜 하는지

### 블랙박스 테스트 & 화이트박스 테스트
블랙박스(명세기반) 테스트  
: 내부 경로에 대한 지식을 보지 않고 테스트 대상의 기능이나 성능을 테스트  
화이트박스(구현기반) 테스트  
: 모듈의 논리적인 구조를 체계적으로 점검 - 구조적 테스트  
테스트 과정  
1. 원시 코드를 통해 애플리케이션의 구조를 이해 - 논리 흐름도  
2. 검증 기준을 정한다.  
3. 각 경로를 구동시키는 테스트 데이터 준비    

블랙 & 화이트 차이  
: 블랙박스 시험만 가지고는 프로그램의 모든 실행문이 실제로 실행되는 지 알 수 없다. 이는 모듈이 사용하고 있는 모든 변수와 상수, 서브루틴의 실행을 포함한다.  
: 블랙박스 시험만 가지고는 부작용을 예측하기 어렵다. 모듈이 실행되어 전역 변수의 값을 변하게 하는 것도 이러한 부작용의 예이다.  

### 테스트 절차  
- 테스트 계획  
    - 테스트 목표 정의
    - 테스트 대상 및 범위 결정
    - 테스트 계획서 작성 및 검토  
    - 테스트 케이스 설계 기법 정의
    - 테스트 케이스 도출
    - 원시 데이터 작성 

- 테스트 실행 및 측정
    - 테스트 환경 구축
    - 테스트 실행 및 측정
    - 테스트 결과 분석
    - 보고서 작성 테스트 결과 
- 오류 추적 및 수정
    - 오류 수정 계획
    - 오류 수정
    - 수정된 내용 검토
- 확인 테스트
- 검증 테스트

### 정적 테스트
: 프로그램을 실행하지 않고 코드를 검토하며 오류를 찾는 방법  
### 경계값 분석  
: 동치 클래스의 경계에서 문제를 발생하는 특수한 값이 존재  
동치 클래스 경계에 있는 값을 가진 테스트 케이스는 높은 효율을 가짐   
동치클래스의 경계에 있는 값을 테스트 입력으로 선택  

### 원인과 결과 그래프
입력 조건의 조합을 체계적으로 선택하는 테스트 기법  
노드와 기호로 표시  
노드 : 원인(입력조건) , 결과(출력 조건)  

### 하향식 통합  
시스템 구조상 최상위에 있는 모듈부터 통합  
### 상향식 통합  
시스템 구조상 최하위에 있는 모듈부터 통합
### 연쇄식 통합  
특정 기능을 수행하는 모듈의 최소 단위(thread)로부터 시작  

### 프로젝트 9가지 관점 외울 필요 x 옳고 그른거 객관식으로 낼 수 o 

<img src="../image/프로젝트 관리의 9가지 관점.png" width = 50%>

### 형상 관리란  
: 소프트웨어 품질 관리 활동  
: 소프트웨어 개발의 전 단계에 걸쳐 진행됨  

### 형상 통제 위원회(CCB)  
형상 통제는 변경 요청이 발생했을 때 해당 변경에 대한 평가, 조정, 변경 승인 등의 활동을 수행하는 단계인데 CCB에서 진행. CCB가 승인한 변경 사항은 형상관리 데이터베이스에 저장 관리 됨   
주요 업무  
베이스라인 변경의 승인  
변경 요청에 대한 평가  
변경 요청의 승인 및 기각 결정  
변경 요청의 종결 처리  


### 형상관리 테스트
### 형상관리 정의(의미) 절차따라 왜 변경?
형상관리활동은 소프트웨어 개발 활동과 통합해 수행해야 함   
절차  
형상 식별  
: 형상 항목을 식별하기 위한 기준을 정의한다.  
형상 통제  
:CCB에서 진행
상태 보고  
: 형상 항목에 대한 상태를 기록하고 보고하는 활동  
형상 감사  
: 개발된 소프트웨어 제품이 승인된 제품의 명세와 정확히 일치하는지를 평가하는 활동  

### 버전은 뭐고 왜 관리해야하는지
소프트웨어에서 버전 : 개발 단계 또는 순서를 번호로 표시한 것  
왜 관리해야하는지  

여러 명이 함께 작성한 내용을 서로 공유하며 작업을 할 경우  
누군가는 이전 버전의 파일로 계속 작업을 한다면 잘못된 결과를 얻음  
요구사항이 자주 변경되는 현실에서 버전 관리가 잘 되어야만 정확한 결과를 도출 할 수 있음  

버전 관리  
릴리스 1.0 : 요구분석명세서(v1.1) - 설계서(v1.2) - 원시코드(v1.1)  
릴리스 2.0 : 요구분석명세서(v1.2) - 설계서(v1.3) - 원시코드(v1.3)  
릴리스 3.0 : 요구분석명세서(v1.3) - 설계서(v1.4) - 원시코드(v1.5)  

### 형상감사 큰개념
개발된 소프트웨어 제품이 승인된 제품의 명세와 정확히 일치하는지를 평가하는 활동  
형상 항목이 베이스라인을 통해 배포되기 직전 또는 변경을 반영한 소프트웨어 제품이 사용자에게 배포되기 전 수행  
### 리펙토링(주관식) 왜하는지
### 리팩토링  
: 외부 동작을 바꾸지 않으면서 내부 구조를 개선하는 방법  
: 소프트웨어 시스템을 변경하는 프로세스  
목적  
: 소프트웨어의 설계 사항 개선  
: 리팩토링을 수행하지 않는 소프트웨어는 유지보수를 거치면서 본래 의도했던 설계 구조가 무너짐 => 리팩토링을 통해 설계 구조 유지 가능  
: 리팩토링은 소프트웨어에 대한 가독성과 이해도를 높임  
: 리팩토링을 통해 코드 구조를 변경할 때, 버그를 찾도록 도와줌  
: 리팩토링은 코드 가독성을 높여 프로그램을 신속히 작성할 수 있음  
### 품질부분 외우려면 내용 너무 많으니 짚어준 부분만
### 각각 iso-9126모델까지 (ISO 모델의) 신뢰성 사용성 어쩌고 품질목표 11개
ISO/IEC 9126   
ISO/IEC 9126-1(품질 모델)  
: 6가지 품질 특성과 소프트웨어 품질의 품질 평가를 위한 프레임워크를 정의  
ISO/IEC 9126-2(외부 품질)  
: 개발자를 위한 표준  
: 완성된 소프트웨어의 성능, 오류발생, 사용 용이성 등이 여기에 해당  
ISO/IEC 9126-3(내부 품질)  
: 구매자를 위한 표준  
ISO/IEC 9126-4(사용 품질)  
: 사용자를 위한 표준으로 사용 품질을 정의  
9126의 품질 특성 및 하위 특성  
기능성  
: 개발된 소프트웨어가 특정 조건에서 사용될 때 개발 전에 의도했던 대로 정확하게 사용자의 요구를 만족하는 기능을 제공하는지 여부를 나타냄  
신뢰성  
: 소프트웨어를 믿고 사용할 수 있는지 여부를 나타냄  
사용성  
: 편리한 기능을 제공하는 정도를 나타냄  
효율성  
유지보수  
이식성  

### 품질 보증, 품질 관리 정의  
개발 단계 전역에 걸쳐 품질에 영향을 미치는 문제점을 조기에 발견하여 제거하는 것  
개발된 소프트웨어의 품질이 목표한 수준에 있다는 것을 보증  
프로젝트 관리, 문서화 등처럼 소프트웨어 개발 단계 전역에 걸쳐 적용되는 보호 활동  