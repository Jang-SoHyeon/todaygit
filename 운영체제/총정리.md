기억장치 관리 (Memory Management)  
기억장치 (DRAM) : 주소를 가지는 워드 (또는 바이트)들로 구성  
프로그램이 실행되기 위해서는 기억장치에 적재되어야 한다.
적재된 프로그램 : 프로세스
프로세스의 일반적인 실행   
- 프로그램 계수기에서 가리키고 있는 주소에서 명령어를 CPU로 가져옴(fetch)  
- 명령어를 해독(decode)
- 기억장치에서 피연산자를 CPU로 가져와서 피연사자에 대해 명령어를 실행(execute)
- 실행한 결과를 기억장치에 다시 저장(store)

주소 바인딩(Address Binding)  
: 프로그램의 명령어와 데이터를 기억장치에 적재할 때, 그것들의 기억장치 주소를 결정하는 것
: 바인딩의 시간에 따라 3가지 종류가 있음
1. 컴파일 시간 (compile time) 바인딩
- 컴파일 시간에 절대 코드(absolute code)를 생성한다.
- 프로그램을 기억장치 내에 적재할 위치를 컴파일 시간에 결정함.
- 적재 위치를 바꾸려면 다시 컴파일 해야 한다.

2. 적재 시간 (load time) 바인딩
- 컴파일 시간에 재배치 코드(relocatable code)를 생성
- 적재 시간에 적재할 위치를 결정함

3. 실행 시간 (execution time) 바인딩
- 프로세스가 실행 중에 기억장치의 한 세그먼트로부터 다른 세그먼트로 이동될 수 있다.
- 바인딩은 실행시간에 결정됨

(현재 컴퓨터들은 매우 큰 논리 주소 공간을 지원하므로, 페이지 테이블의 크기가 매우 크다.)
 해결 방법들
 - 계층적 페이징(Hierarchical paging)
 - 해쉬된 페이지 테이블 (Hashed Page Tables)
 - 역 페이지 테이블 (Inverted Page Tables)

 계층적 페이징 (페이지 테이블 구조)
 : 페이지 테이블 전체 내용을 메인 메모리에 연속적으로 할당하는 대신에, 페이지 테이블을 페이지 단위로 나누고, 필요한 부분만 메인 메모리에 할당함 (페이지 테이블 자체를 페이지화)  
 <img src = "../image/계층적 페이징.png">
   
**2단계 페이징 기법 (two-level paging scheme)** 
 
- 32-bit 주소 공간을 가진 컴퓨터에서 페이지 크기가 4KB라면, 논리 주소는 
    - 20비트의 페이지 번호 (P)
    - 12비트의 페이지 변위 (d)로 구성됨 





디스크 공간 할당 방법  
- 연속 할당 (Contiguous Allocation)
: 파일을 저장할 때 디스크의 연속된 블록을 할당하여 저장  
: 디렉토리에 파일이 저장된 시작 블록과 길이(블록의 개수)에 대한 정보를 관리  
장점   
- 순차 접근과 직접 접근이 모두 가능  
단점  
- 파일을 저장할 때 적절한 빈 블록들을 찾는 문제  
- 파일이 커지는 경우, 연속공간이 없으면 파일이 커질 수 없다.
- 외부 단편화 문제
    - 파일들이 할당되고 삭제되면서 파일에 할당된 블록들 사이에 가용 블록들이 생김
    - 새로 생성되는 파일의 크기가 커서 이러한 가용 블록에 저장할 수 없다면 외부 단편화 문제가 발생
    - 해결책 : 공간 압축  
      
- 연결 할당
: 파일의 블록을 디스크에 여기저기 저장하고, 블록들을 차례로 연결하는 방법  
: 디렉토리에 파일의 시작 블록과 마지막 블록의 번호를 저장  
: 디스크 블록마다 다음 블록 번호를 저장  
장점  
: 외부 단편화 문제가 없다.  
단점  
: 직접 접근이 어렵다.  
: 디스크 블록의 공간 소비 (다음 블록 번호를 저장해야 함)  
  
- 색인 할당  
: 파일마다 색인 블록을 갖고, 색인 블록에 파일의 모든 블록의 번호를 저장하는 방법   
: 디렉토리는 파일의 색인 블록 번호를 가진다.  
장점  
: 순차 접근과 직접 접근이 모두 가능  
: 외부 단편화 문제가 없다.  
단점  
: 색인 블록이 공간 낭비를 초래할 수 있다. 특히, 파일의 크기가 작을 때가 색인 블록이 대부분 낭비됨 


### 다음 그림을 설명하시오
<image src = "../image/스레싱.png" width = 55%>
다중 프로그래밍의 정도가 높아짐에 따라 CPU 사용률이 높아지지만, 다중 프로그래밍의 정도가 어느 한도를 넘게되면 스레싱이 일어나고 CPU 사용률도 급격히 떨어진다. 

- 이런 경우 CPU 사용률도 높이고 스레싱을 중지하려면, 다중 프로그래밍이 정도를 낮추어야 한다.  



### 프로세스 동기화(synchrnization)  
병행 프로세스(동시에 수행되는 프로세스)들이 서로 데이터를 주고 받으면서 수행될 때, 이 프로세스들 가의 동기화가 필요하다.  
병행 프로세스들이 공유 데이터를 접근할 때, 병행 접근하면 데이터의 일관성(data consistency)이 잘못될 수 있다.  
데이터의 일관성을 유지하려면 데이터 접근을 순서화해야 한다.  

### 2차 기회(Second chance) 알고리즘  
: 페이지마다 참조 비트가 있으며 이들은 순환 큐로 관리됨  
: 포인터(next victim)가 다음에 교체될 페이지를 가리킨다.
: 교체할 프레임이 필요해지며, 포인터는 참조비트는 0인 것을 발견할 때까지 계속 찾으면서 참조비트들을 0으로 지운다. 
: 즉, 참조비트가 1인 것은 2차 기회를 제공하면서 포인터는 큐를 한바퀴 돈다.  
: 참조비트가 0인 것을 찾게 되면, 그 페이지는 교체되고 새로운 페이지가 그 위치에 삽입된다.  


### MMU가 주소 변환 과정에서 발생시킬 수 있는 인터럽트 2가지를 설명하시오   
1. 주소 변환 도중에 해당 페이지의 유효-무효 비트가 0이면, 페이지 부재(page fault) 인터럽트가 발생함
(MMU에서 인터럽트를 일으킴)
2. 요구 페이징은 새로 참조된 페이지가 기억장치에 없으면, 그 페이지를 기억장치에 적재시킴
- 주소 변환 과정에서 페이지 부재 인터럽트를 발생하고 운영체제가 수행되며 운영체제는 새 페이지를 기억장치에 적재시킴  ?????

  

### 프로세스의 기억장치 할당 기법 중에 연속 할당기법이 있다. 연속 할당 기법에서 사용할 수 있는 가용공간 할당 방법 3가지를 설명하시오.  
- 최초 적합(fIRST-fit) 
: 충분한 것 중에서 첫 번째 가용 공간에 할당  
- 최적 적합(Best-fit)
: 충분한 것 중에서 가장 작은 가용 공간에 할당. 가장 작은 hole을 만들게 됨  
- 최악 적합(worst-fit)
: 충분한 것 중에서 가장 큰 가용 공간에 할당, 가장  큰 hole을 만들게 됨  

### 페이지 교체 알고리즘에서 전역 교체와 지역 교체를 설명하시오
:전역 교체는 모든 프레임에서 교체할 프레임을 선택하는 방법이고 지역 교체서의 각 프로세스는 자신에게 할당된 프레임 중에서 교체할 프레임을 선택  



#### 180p부터