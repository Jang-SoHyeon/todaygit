기억장치 관리 (Memory Management)  
기억장치 (DRAM) : 주소를 가지는 워드 (또는 바이트)들로 구성  
프로그램이 실행되기 위해서는 기억장치에 적재되어야 한다.
적재된 프로그램 : 프로세스
프로세스의 일반적인 실행   
- 프로그램 계수기에서 가리키고 있는 주소에서 명령어를 CPU로 가져옴(fetch)  
- 명령어를 해독(decode)
- 기억장치에서 피연산자를 CPU로 가져와서 피연사자에 대해 명령어를 실행(execute)
- 실행한 결과를 기억장치에 다시 저장(store)

주소 바인딩(Address Binding)  
: 프로그램의 명령어와 데이터를 기억장치에 적재할 때, 그것들의 기억장치 주소를 결정하는 것
: 바인딩의 시간에 따라 3가지 종류가 있음
1. 컴파일 시간 (compile time) 바인딩
- 컴파일 시간에 절대 코드(absolute code)를 생성한다.
- 프로그램을 기억장치 내에 적재할 위치를 컴파일 시간에 결정함.
- 적재 위치를 바꾸려면 다시 컴파일 해야 한다.

2. 적재 시간 (load time) 바인딩
- 컴파일 시간에 재배치 코드(relocatable code)를 생성
- 적재 시간에 적재할 위치를 결정함

3. 실행 시간 (execution time) 바인딩
- 프로세스가 실행 중에 기억장치의 한 세그먼트로부터 다른 세그먼트로 이동될 수 있다.
- 바인딩은 실행시간에 결정됨

(현재 컴퓨터들은 매우 큰 논리 주소 공간을 지원하므로, 페이지 테이블의 크기가 매우 크다.)
 해결 방법들
 - 계층적 페이징(Hierarchical paging)
 - 해쉬된 페이지 테이블 (Hashed Page Tables)
 - 역 페이지 테이블 (Inverted Page Tables)

 계층적 페이징
 : 페이지 테이블 전체 내용을 메인 메모리에 연속적으로 할당하는 대신에, 페이지 테이블을 페이지 단위로 나누고, 필요한 부분만 메인 메모리에 할당함 (페이지 테이블 자체를 페이지화)  
 <img src = "../image/계층적 페이징.png">
   
**2단계 페이징 기법 (two-level paging scheme)** 
 
- 32-bit 주소 공간을 가진 컴퓨터에서 페이지 크기가 4KB라면, 논리 주소는 
    - 20비트의 페이지 번호 (P)
    - 12비트의 페이지 변위 (d)로 구성됨 